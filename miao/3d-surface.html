<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D 平面绘制</title>
</head>
<style>

  html {
    background-color: rgba(0, 0, 0, .3);
  }

  .wrap {
    height: 800px;
    transform-style: preserve-3d;
  }

  #surface {
    position: relative;
    transform:  perspective(1000px) scale3d(2,2,2);
    transform-style: preserve-3d;
  }

  .surface-slice {
    display: inline-block;
    position: absolute;
    background-color: palevioletred;
  }

  .flex-center {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /*
    旋转相关
  */
  .btn {
    display: inline-block;
    border: 1px solid;
    position: relative;
    z-index: 10;
  }

  .rotate-x-btn:hover ~ .wrap-x {
    animation-play-state: running;
  }

  .wrap-x {
    animation: spin-x infinite linear 6s;
    animation-play-state: paused;
  }


  .rotate-z-btn:hover ~ .wrap .wrap-z {
    animation-play-state: running;
  }

  .wrap-z {
    animation: spin-z infinite linear 6s;
    animation-play-state: paused;
  }


  .rotate-y-btn:hover ~ .wrap .wrap-y {
    animation-play-state: running;
  }

  .wrap-y {
    animation: spin-y infinite linear 6s;
    animation-play-state: paused;
  }

  @keyframes spin-x {
    from {
      transform: rotateX(0deg);
    }

    to {
      transform: rotateX(360deg);
    }
  }

  @keyframes spin-y {
    from {
      transform: rotateY(0deg);
    }

    to {
      transform: rotateY(360deg);
    }
  }

  @keyframes spin-z {
    from {
      transform: rotateZ(0deg);
    }

    to {
      transform: rotateZ(360deg);
    }
  }
</style>
<body>
<div class="btn rotate-x-btn">绕 X 轴旋转</div>
<div class="btn rotate-y-btn">绕 Y 轴旋转</div>
<div class="btn rotate-z-btn">绕 Z 轴旋转</div>

<div class="wrap wrap-x">
  <div class="wrap wrap-z">
    <div class="wrap wrap-y flex-center">
      <div id="surface"
           class="flex-center"
      ></div>
    </div>
  </div>
</div>

<script>

  let pricision = 3
  let scaleFactor = 50
  // 1, 要保证 slice 的双向尺寸大于 1, 否则会造成平移后的重叠
  // 比如 x 方向尺寸 0.5px, 平移 0.5px. 实际浏览器会把 x 方向尺寸(width)设置为 1px(因为至少 1 px 起画), 那么相邻 slice 就会重叠 0.5px
  // 2, 同时又要画出[-PI, PI] 范围内的曲面, 尽可能 slice 要小(以直代曲效果好), 但又不能太多(性能)
  //    所以引入一个 scaleFactor 变量, 作用是相当于将函数等比例放大
  //    比如scaleFactor = 2,
  //        那么当x 实际取值范围 -2PI <= x <= 2PI, 那么 -PI <= x / scaleFactor  <= PI
  //        计算 z 时使用 x / scaleFactor 即可
  let sliceDimX = (Math.PI / 8) * scaleFactor
  let sliceDimY = sliceDimX

  let surfaceDimX = roundFun(sliceDimX * 12, pricision)
  let surfaceDimY = roundFun(sliceDimY * 12, pricision)

  let surfaceDom = document.getElementById('surface')

  let transXBoundary = Math.PI * scaleFactor
  let transYBoundary = Math.PI * scaleFactor


  surfaceDom.style.height = surfaceDimY + 'px'
  surfaceDom.style.width = surfaceDimX + 'px'

  function createDiv() {
    let transX,transY,transZ
    let rotateY, rotateX
    let slicesHtml = ''

    for (let x = -transXBoundary; x <= transXBoundary; x += sliceDimX) {
      console.log(x)
      for (let y = -transYBoundary; y <= transYBoundary; y += sliceDimY) {

        // 0, 计算矩形面中点处的坐标, 从而得到其相对于(0,0)的偏移值
        transX = roundFun(x, pricision)
        transY = roundFun(y, pricision)
        let scaledX = x / scaleFactor
        let scaledY = y / scaleFactor
        transZ = roundFun(Math.sin(scaledX) + Math.cos(scaledY), pricision) * scaleFactor

        // 1, 矩形面需要旋转角度才能去逼近曲面
        // f'x(x, y) = cos(x)
        // f'y(x, y) = -sin(x)

        rotateY = Math.atan(Math.cos(scaledX)) / Math.PI * 180 * -1  // f'x(x, y) 转换为角度时 arctan(f'x(x, y)) 角度为负, 是 x 转向 z
        rotateX = Math.atan(-Math.sin(scaledY)) / Math.PI * 180  // f'y(x, y) 转换为角度时 arctan(f'y(x, y))  角度为正, 是 y 转向 z

        // 2, 矩形面旋转后, 其 x 和 y 方向的尺寸也要改变
        // inclinedSliceDim = sliceDim / cos(theta)
        // 因为 -1<= tan(theta) <=1
        // 所以 theta 的变化范围是 [-pi/4, pi/4], cos(theta)的值都是正的, 所以不用管 theta 的正负

        let inclinedSliceDimX = sliceDimX / Math.cos(rotateY / 180 * Math.PI)
        let inclinedSliceDimY = sliceDimY / Math.cos(rotateX / 180 * Math.PI)

        // 3, 根据 z 方向的坐标设置颜色
        let color = Math.abs(transZ / scaleFactor) / 2 * 255
        let sliceHtml = `<div class="surface-slice"
                                  style="
                                  height: ${inclinedSliceDimY}px;
                                  width: ${inclinedSliceDimX}px;
                                  background-color: rgb(${color},0,0);
                                  transform:
                                    translateX(${transX}px) translateY(${transY}px) translateZ(${transZ}px) rotateY(${rotateY}deg) rotateX(${rotateX}deg)"
                         ></div>`

        slicesHtml +=sliceHtml
      }
    }

    surfaceDom.innerHTML = slicesHtml
  }

  function roundFun(value, n) {
    // JavaScript 的 Math.round()函数对于 -1.5 的情况, 与预期不同
    // Math.round(-1.5) ----> -1
    // 需要先转换为绝对值进行取整
    let num = Math.round(Math.abs(value) * Math.pow(10, n)) / Math.pow(10, n)

    num = parseFloat(num.toFixed(n))

    if (Number(value) < 0) {
      num *= -1
    }
    return num
  }
  createDiv()

</script>
</body>
</html>