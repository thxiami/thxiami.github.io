###   flex`布局中各个`flex-item`位置和尺寸的确定(重点是交叉轴上的布局)

#### 0 先看一个`Demo`

- HTML和 CSS 代码

```html
  <div class="parent">
    <div class="child">C1</div>
    <div class="child">C2</div>
  </div>
```

```css
.parent {
  height: 300px;
  width: 250px;

  display: flex;
  flex-wrap:wrap;
  
  border: 1px solid;
  background-color: limegreen;
}

.child {
  width: 200px;
  border: 1px solid;
  background-color: pink;
}

```

- 效果

  -  ![](https://raw.githubusercontent.com/thxiami/thxiami.github.io/master/miao/note/img/flex-demo-1.png)    ![](<https://raw.githubusercontent.com/thxiami/thxiami.github.io/master/miao/note/img/flex-demo-2.jpeg>)

- [Demo](<https://jsbin.com/melafuk/edit?html,css,output>)

图上可以看出两个`flex-item` : `C1`和 `C2`高度分别为 `150px`, 看来是均分了`flex-container`在`cross-axis`方向上的空间. 经过查阅[规范](<https://www.w3.org/TR/css-flexbox-1/#layout-algorithm>), 背后的计算过程是这样的

- 讲之前,我们先约定几个术语:

  - `flex-container`和`flex-item`

    - > A <span style="color:red">flex container</span> is the box generated by an element with a computed [display](https://www.w3.org/TR/css-display-3/#propdef-display) of [flex](https://www.w3.org/TR/css-flexbox-1/#valdef-display-flex) or [inline-flex](https://www.w3.org/TR/css-flexbox-1/#valdef-display-inline-flex). In-flow children of a flex container are called <span style="color:red">flex items </span>and are laid out using the flex layout model.

  - `main size`

    - > The width or height of a [flex container](https://www.w3.org/TR/css-flexbox-1/#flex-container) or [flex item](https://www.w3.org/TR/css-flexbox-1/#flex-item), whichever is in the [main dimension](https://www.w3.org/TR/css-flexbox-1/#main-dimension), is that box’s main size. Its main size property is thus either its [width](https://www.w3.org/TR/CSS21/visudet.html#propdef-width) or [height](https://www.w3.org/TR/CSS21/visudet.html#propdef-height) property, whichever is in the [main dimension](https://www.w3.org/TR/css-flexbox-1/#main-dimension).Similarly, its min and max main size properties are its [min-width](https://www.w3.org/TR/CSS21/visudet.html#propdef-min-width)/[max-width](https://www.w3.org/TR/CSS21/visudet.html#propdef-max-width) or [min-height](https://www.w3.org/TR/CSS21/visudet.html#propdef-min-height)/[max-height](https://www.w3.org/TR/CSS21/visudet.html#propdef-max-height) properties, whichever is in the [main dimension](https://www.w3.org/TR/css-flexbox-1/#main-dimension), and determine its min/max main size.

    - 经过阅读规范来看, `main size` 分为

      -  [hypothetical main size](https://www.w3.org/TR/css-flexbox-1/#hypothetical-main-size) : `flex-basis`的值, 同时还要满足 `min-*/max-*`的限制
      -  `used main size`: 经过布局计算后实际使用的值, 也就是画出来的值

    - 简单来说, 假如 `flex-direction: row`

      - `hypothetical main size`就是综合`flex-basis`和`min-width/max-width`后的值
      -  `used main size`就是布局计算后的值. 
      - 注意: 如果显示声明了`width`属性,那么`hypothetical main size`和`used main size`都是`width`

  - `cross size`

    - 跟`main size`正好相反, 是`cross axis`方向上的空间尺寸
    - 简单来说, 假如 `flex-direction: row`
      - `hypothetical cross size`就是综合`height`和`min-height/max-height`后的值, <span style="color:red">TODO:</span> 验证 min-height, 如果设置为`auto`, 那么会按照`fit-content`计算(参见[Determine the hypothetical cross size of each item](<https://www.w3.org/TR/css-flexbox-1/#algo-cross-item>)

        - > **Determine the hypothetical cross size of each item** by performing layout with the used [main size](https://www.w3.org/TR/css-flexbox-1/#main-size) and the available space, treating [auto](https://www.w3.org/TR/css-sizing-3/#valdef-width-auto) as fit-content.

      - `used cross size`就是布局计算后的值

      - 注意: 如果显示声明了`height`属性,那么 `hypothetical cross size`和`used cross size`都是`height`

  - 针对本`Demo`

    - `flex-container`: `class="parent"`的元素
      - `main size`
        -  `hypothetical main size: 250px`
        - ` used main size: 250px`
      - `cross size`
        - `hypothetical cross size: 300px`
        - ` used cross size: 300px`
    - `flex-item`
      - `class="child"`的 2 个元素
      - `main size`
        -  `hypothetical main size: 200px`
        - ` used main size: 200px`
      - `cross size`
        - `hypothetical cross size: auto -> fit-content ->0`
        - ` used cross size: 150px` 这是经过一系列计算得到的, 计算过程见下方

#### 1 看看怎么计算尺寸和布局的

tips:第1步其实要先确定`flex container`在主轴方向上的尺寸. 但是本 Demo 已经显示指定了其尺寸(`width:250px`), 所以跳过该步骤. 详情参见[Line Length Determination](<https://www.w3.org/TR/css-flexbox-1/#line-sizing>)

#### 1.1 计算`flex container`内部元素的尺寸

##### 1.1.1 主轴空间上的元素尺寸(参考[Main Size Determination](<https://www.w3.org/TR/css-flexbox-1/#main-sizing>))

- > Collect flex items into flex lines:
  >
  > - If the flex container is [single-line](https://drafts.csswg.org/css-flexbox/#single-line-flex-container), collect all the flex items into a single flex line.
  >
  > - Otherwise, starting from the first uncollected item, collect consecutive items one by one until the first time that the next collected item would not fit into the flex container’s inner main size (<span style="color:red">or until a forced break is encountered, see §10 Fragmenting Flex Layout</span>). If the very first uncollected item wouldn’t fit, collect just it into the line.
  >
  >   For this step, the size of a flex item is its [outer](https://drafts.csswg.org/css-sizing-3/#outer-size) [hypothetical main size](https://drafts.csswg.org/css-flexbox/#hypothetical-main-size). (Note: This can be negative.)
  >
  >   Repeat until all flex items have been collected into flex lines.

- 如果大家很难看得下去上面的话,那么对应于本`Demo`就是.......
- 将`C1`和`C2`沿着主轴方向依次放,  结果它俩的 `main size`之和(`400px`)超过了 `flex-container`主轴方向上`main size`(`300px`), 这时候怎么办呢? 参考<span style="color:red">红色文字</span>, 因为设置了 `flex-wrap: wrap`, 所以会把放不下的`C2`元素放在下一行(`flex line`)

##### 1.1.2 接下来计算交叉轴(`cross-axis`)空间上的元素尺寸(参考[Cross Size Determination](<https://www.w3.org/TR/css-flexbox-1/#cross-sizing>))

- 我就不放规范了.....下面依次根据本Demo 介绍布局的计算步骤
1. 计算每个`flex-item`的`hypothetical cross size`, 因为未设置`height`, 所以`hypothetical cross size`=`height:auto  -> fit-content -> 没有子元素 -> 0`

2. 计算每个`flex line`的`cross size`,  一共有两行(两个`flex line`), 每行内最大的`flex-item`的`hypothetical cross size=0`, 所以每个`flex line`的`cross size=0`

3. 因为设置了`align-content:stretch`, 同时`flex-container`显式设置了`cross size`(300px), 所以剩余空间会被平均分配增加至每个`flex line`的`cross size`.  每个`flex line 的 cross size= 0 + (300 - 0 * 2) / 2 = 150px `

4. 计算每个`flex-item`的`used cross size`, 假如同时满足以下三个条件,  `used cross size`等于所在行(`flex line`)的`used cross size`:

   1. `align-self: stretch`
   2.  ` 计算 cross size 使用的属性值为 auto, 即height: auto`
   3.  `cross-axis 方向上的 margin 都不为 auto`

   如果不满足任一条件, `used cross size`等于`hypothetical cross size`

5. Demo 中`C1 和 C2`元素符合以上条件, 所以每个`flex-item`的`used cross size=150px`(即 `height`)占满所在`flex line`

#### 1.2 确定`flex container`内部元素的布局

##### 1.2.1 主轴中的对齐 --参考[Main-Axis Alignment](<https://www.w3.org/TR/css-flexbox-1/#main-alignment>)

- 对于每一个`flex line`, 首先确认内部的`flex-item`是否有`main-axis`方向上的 `margin`设置为`auto`(demo 中即看是否把`margin-left`,  `margin-right`设置为`auto`. )
  - 如果有设置, 那么判断主轴方向的剩余空间为正值还是负值(就是把所有的`flex-item`的 `used main size`相加与`flex container`的 `inner main size`对比)
    - 剩余空间为正值, 那么就把剩余空间等分, 然后把等分后的值赋给设置了`auto`属性的`margins`
    - 剩余空间为负值, 所有设置`auto`属性值的`marigns`设置为`0`
  - 如果没有 `margin` 设置为`auto` , 那么在其内部通过`justify-content`来确认怎么对齐
- Demo中没设置, 所以`C1和C2`根据默认的`justify-content:flex-start`对齐在左侧

##### 1.2.2 每个` flex line`中交叉轴方向上的对齐 --参考[Cross-Axis Alignment](<https://www.w3.org/TR/css-flexbox-1/#cross-alignment>)

- 对于每一个`flex line`, 首先确认内部的`flex-item`是否有`cross-axis`方向上的 `margin`设置为`auto`(demo 中即看是否把`margin-top`,  `margin-bottom`设置为`auto`. ).
  -  如果设置了`cross-axis`方向上的`margin`为`auto`, 那么判断`flex-item`的`outer cross size(used cross size + margin, 其中属性为 auto 的 margin算为 0)`之和是否超过了`flex line`的 `cross size`
    -  如果没超过, 那么把剩余空间平均分配后赋给设置了 `auto`属性值的`margins`. 
    - 如果超过了?<span style="color:red">TODO:规范说设置相反的margin保证 flex-item 的 cross size 不超过 flex line 的 cross size, 但是暂时还不知道什么情况下能超过</span>
  - 如果没设置`cross-axis`方向上的`margin`为`auto`,那么根据`align-self`属性决定`flex-item`在`flex line`内如何对齐
- Demo中没设置, 同时由1.1.2 章节中最后一步可知`C1和C2`根据默认的`align-self:stretch`占满了所在`flex line`

##### 1.2.3 确认`flex-container`中交叉轴方向上各个` flex line`的对齐

1. 确定`flex-container`内部的` used cross size`

- 为什么要确定这个值?
  - 确定这个值以后, 才能根据`align-content`属性来对齐各个` flex line`在`cross axis`方向上的位置
- 如何确定这个值?
  - 在`flex-container`没有给定`cross size`时, 根据之前步骤中确定的所有`flex line`的`cross size`之和以及`flex-container`设定的`min-* / max-*`限制来确定这个值
  - 在`flex-container`给定`cross size`时, 直接使用这个值. 比如 Demo 中设置了`height: 300px`
- 如何对齐各个` flex line`?
  - 根据`flex-container`设置的`align-content`属性来确定

### 思考题

#### 1. 如果给`C1` 和 `C2`设置了相同高度(小于` flex line `的`cross size`), 会怎么样呢?

  ```css
  .child {
    height: 100px;
    width: 200px;
    border: 1px solid;
    background-color: pink;
  }
  ```

- 效果如图:   ![](https://raw.githubusercontent.com/thxiami/thxiami.github.io/master/miao/note/img/flex-test-1.png)
- [Jsbin Demo](<https://jsbin.com/xihivis/4/edit?html,css,output>)

#### 2. 如果给`C1` 和 `C2`设置了不同高度, 又会怎么样呢?

```css
.child {
    width: 200px;
    border: 1px solid;
    background-color: pink;
}

.child:nth-child(1) {
    height: 100px;
}
  .child:nth-child(2) {
    height: 50px;
}
```

- 效果如图: ![](https://raw.githubusercontent.com/thxiami/thxiami.github.io/master/miao/note/img/flex-test-2.jpeg)

- [Jsbin Demo](https://jsbin.com/xihivis/6/edit?html,css,output)

#### 3. 如果给`C1` 和 `C2`设置了相同高度, 又设置了 `margin-top/ margin-bottom` 为`auto`又会怎么样呢?

```css
.child {
    height: 100px;
    width: 200px;
    border: 1px solid;
    background-color: pink;
    margin-top: auto;
    margin-bottom: auto;
}
```

- 效果如图: ![](https://raw.githubusercontent.com/thxiami/thxiami.github.io/master/miao/note/img/flex-test-3.jpeg)
- [Jsbin Demo](https://jsbin.com/xihivis/7/edit?html,css,output)

#### 4. 如果给`C1` 和 `C2`设置了相同高度, 设置了 `margin-top:auto;margin-bottom:固定值`, 又会怎么样呢?

```css
.child {
    height: 100px;
    width: 200px;
    border: 1px solid;
    background-color: pink;
    margin-top: auto;
    margin-bottom: 20px;
}

```

- 效果如图: ![](https://raw.githubusercontent.com/thxiami/thxiami.github.io/master/miao/note/img/flex-test-4.jpeg)
- [Jsbin Demo](<https://jsbin.com/xihivis/12/edit?html,css,output>)

#### 5. 如果一行内的 flex-item 高度不同, 同时有多行, 又设置了 `margin-top/ margin-bottom` 为`auto`又会怎么样呢?

```html
  <div class="parent">
    <div class="child c1">C1</div>
    <div class="child c2">C2</div>
    <div class="child c1">C1</div>
    <div class="child c2">C2</div>
    <div class="child c1">C1</div>
    <div class="child c2">C2</div>
  </div>
```

```css
.child {
    width: 80px;
    border: 1px solid;
    background-color: pink;
    margin-top: auto;
    margin-bottom: auto;
}

.c1 {
    height: 100px;
}

.c2 {
    height: 50px;
}
```

- 效果如图: ![](https://raw.githubusercontent.com/thxiami/thxiami.github.io/master/miao/note/img/flex-test-5.jpeg)
- [Jsbin Demo](https://jsbin.com/xihivis/10/edit?html,css,output)



